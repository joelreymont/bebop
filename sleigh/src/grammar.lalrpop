use super::{
	ast::*,
	error::ParseError,
	lexer::{Token as T, NormalToken as NT, DisplayToken as DT},
	meta::*,
};

grammar<'input>(file_id: FileId, ctx: &mut Context);

Located<T>: Loc<T> = <left: @L> <node: T> <right: @R> =>
	Loc::new(node, Span::new(file_id, left..right));

Sep<T, S>: Vec<T> = {
    <mut v:(<T> S)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Infix<L, Op, R>: Expr = {
    <lhs:L> <op:Op> <rhs:R> => 
			Expr::Binary { op, lhs: ctx.add(lhs), rhs: ctx.add(rhs) },
};

pub Ident: Loc<Ident> = {
	Located<"ident"> => <>.map(Ident::new),
};

pub DisplayIdent: Loc<Ident> = {
	Located<"display ident"> => <>.map(Ident::new),
};

pub Defs: Vec<Definition> = <Def+>;

pub Def: Definition = {
	Located<EndianDef> => Definition::Endian(<>),
	Located<AlignmentDef> => Definition::Alignment(<>),
	Located<SpaceDef> => Definition::Space(<>),
	Located<VarnodeDef> => Definition::Varnode(<>),
	Located<TokenDef> => Definition::Token(<>),
	Located<VarnodeAttachDef> => Definition::VarnodeAttach(<>),
	Located<Macro> => Definition::Macro(<>),
	Located<Constructor> => Definition::Constructor(<>),
};

pub EndianDef: Endian = "define" "endian" "=" <Endian> ";";

pub Endian: Endian = {
	"big" => Endian::Big,
	"little" => Endian::Little,
}

pub AlignmentDef: usize = "define" "alignment" "=" <Number> ";";

pub Number: usize = {
	"dec int",
	"hex int",
	"bin int",
};

pub SpaceDef: Space = {
	"define" "space" <id:Ident> <kind:SpaceKind> <mods:SpaceMod+> ";" =>
		Space::new(id, kind, mods),
	"define" "space" <id:Located<"register">> <kind:SpaceKind> <mods:SpaceMod+> ";" =>
		Space::new(id.map(|_| Ident::new("register")), kind, mods),
};

pub SpaceKind: SpaceKind = "type" "=" <space_kind>;

space_kind: SpaceKind = {
	"rom space" => SpaceKind::Rom,
	"ram space" => SpaceKind::Ram,
	"register space" => SpaceKind::Register,
};

SpaceMod: SpaceMod = {
	"size" "=" <Number> => SpaceMod::Size(<>),
	"word size" "=" <Number> => SpaceMod::WordSize(<>),
	"default" => SpaceMod::IsDefault,
};

pub VarnodeDef: Varnode = {
	"define" "register" <mods:VarnodeMod+> "[" <ids:Ident+> "]" ";" =>
		Varnode::new(ids, mods),
};

VarnodeMod: VarnodeMod = {
	"size" "=" <Number> => VarnodeMod::Size(<>),
	"offset" "=" <Number> => VarnodeMod::Offset(<>),
};

pub TokenDef: Token = {
	"define" "token" <id:Ident> "(" <bit_width:Number> ")" <fields:TokenField+> ";" =>
		Token {id, bit_width, fields},
};

pub TokenField: Field = {
	<id:Ident> "=" "(" <start:Number> "," <end:Number> ")" <mods:TokenFieldMod*> =>
		Field::new(id, start, end, mods),
};

pub TokenFieldMod: FieldMod = {
	"signed" => FieldMod::IsSigned,
	"hex" => FieldMod::IsHex,
};

pub VarnodeAttachDef: VarnodeAttach = {
	"attach" "variables" "[" <fields:Ident+> "]" "[" <registers:Ident+> "]" ";" =>
		VarnodeAttach { fields, registers }
};

pub Constructor: Constructor = {
	<start:ConstructorStart> <end:ConstructorEnd> => {
		let (id, display) = start;
		let (pattern, context, body) = end;
		let pattern = pattern.map(|x| ctx.add(x));
		let context = ctx.add_many(context);
		let body = ctx.add_many(body);
		Constructor { id, display, pattern, context, body }
	},
};

pub ConstructorStart: (Loc<Ident>, Display) = {
	<Ident> ":" <Display> "is",
	":" <DisplayIdent> <Display> "is",
};

pub ConstructorEnd: (Option<Expr>, Vec<Expr>, Vec<Expr>) = {
	<p:Pattern?> "unimpl" => (p, Vec::new(), Vec::new()), 
	<p:Pattern?> <c:ConstructorContext> "unimpl" => (p, c, Vec::new()), 
	<p:Pattern?> <c:ConstructorContext> <b:ConstructorBody> => (p, c, b), 
};

pub Display: Display = {
	<mnemonic:Mnemonic> <output:Output> => Display { mnemonic, output },
};

pub Mnemonic: Vec<DisplayPiece> = <MnemonicPiece*> " ";

pub Output: Vec<DisplayPiece> = <OutputPiece*>;

pub MnemonicPiece: DisplayPiece = {
	"caret" => DisplayPiece::Caret,
	<DisplayIdent> => DisplayPiece::Id(<>),
	<"text"> => DisplayPiece::Text(Ident::new(<>)),
}

pub OutputPiece: DisplayPiece = {
	"caret" => DisplayPiece::Caret,
	" " => DisplayPiece::Space,
	<DisplayIdent> => DisplayPiece::Id(<>),
	<"text"> => DisplayPiece::Text(Ident::new(<>)),
}

//
// Bit pattern
// 

pub Pattern: Expr = {
  #[precedence(level="0")] 
	"..." <PatAtomic> =>
		Expr::Unary { op: UnaryOp::AlignRight, rhs: ctx.add(<>) },
	<PatAtomic> "..." =>
		Expr::Unary { op: UnaryOp::AlignLeft, rhs: ctx.add(<>) },
	PatAtomic,
  #[precedence(level="1")] #[assoc(side="left")]
	Infix<Pattern, OpPatAnd, Pattern>,	
  #[precedence(level="2")] #[assoc(side="left")]
	Infix<Pattern, OpPatSeq, Pattern>,	
  #[precedence(level="2")] #[assoc(side="left")]
	Infix<Pattern, OpPatOr, Pattern>,	
};

PatAtomic: Expr = {
	<ExprIdent>,
	<lhs:ExprIdent> <op:PatCondOp> <rhs:PatExpr> =>
		Expr::Binary { op, lhs: ctx.add(lhs), rhs: ctx.add(rhs) },
	"(" <Pattern> ")" => Expr::Paren(ctx.add(<>)),
};

OpPatOr: BinaryOp = "|" => BinaryOp::Or;
OpPatSeq: BinaryOp = ";" => BinaryOp::Join;
OpPatAnd: BinaryOp = "&" => BinaryOp::And;

PatCondOp: BinaryOp = {
	"=" => BinaryOp::Equal,
	"!=" => BinaryOp::NotEqual,
	"<" => BinaryOp::Less,
	">" => BinaryOp::Greater,
	"<=" => BinaryOp::LessEqual,
	">=" => BinaryOp::GreaterEqual,
};

pub PatExpr: Expr = {
  #[precedence(level="0")] 
	FunCall,
	PatExprTerm,
  #[precedence(level="1")] 
	<op:PatExprOpUnary> <expr:PatExpr> => Expr::Unary { op, rhs: ctx.add(expr) },
  #[precedence(level="2")] #[assoc(side="left")]
	Infix<PatExpr, PatExprOpMul, PatExpr>,
  #[precedence(level="3")] #[assoc(side="left")]
	Infix<PatExpr, PatExprOpAdd, PatExpr>,
  #[precedence(level="4")] #[assoc(side="left")]
	Infix<PatExpr, PatExprOpShift, PatExpr>,
  #[precedence(level="4")] #[assoc(side="left")]
	Infix<PatExpr, PatExprOpAnd, PatExpr>,
  #[precedence(level="5")] #[assoc(side="left")]
	Infix<PatExpr, PatExprOpXor, PatExpr>,
  #[precedence(level="6")] #[assoc(side="left")]
	Infix<PatExpr, PatExprOpOr, PatExpr>,
};

PatExprTerm: Expr = {
	<ExprIdent>,
	<ExprNumber>,
	"(" <PatExpr> ")" => Expr::Paren(ctx.add(<>)),
};

PatExprOpOr: BinaryOp = "$or" => BinaryOp::LogOr;
PatExprOpXor: BinaryOp = "$xor" => BinaryOp::LogXor;
PatExprOpAnd: BinaryOp = "$and" => BinaryOp::LogAnd;

PatExprOpShift: BinaryOp = {
	"<<" => BinaryOp::ShiftLeft,
	">>" => BinaryOp::ShiftRight,
};

PatExprOpAdd: BinaryOp = {
	"+" => BinaryOp::Plus,
	"-" => BinaryOp::Minus,
};

PatExprOpMul: BinaryOp = {
	"*" => BinaryOp::Plus,
	"/" => BinaryOp::Minus,
};

PatExprOpUnary: UnaryOp = {
	"-" => UnaryOp::Neg,
	"~" => UnaryOp::Inv,
};

//
// Expr
//

pub Expr: Expr = {
  #[precedence(level="0")]
	FunCall,
	ExprTerm,	
  #[precedence(level="1")] 
	<op:OpUnary> <expr:Expr> => Expr::Unary { op, rhs: ctx.add(expr) },
	SizedPointer<Expr>,
  #[precedence(level="2")] #[assoc(side="left")]
	Infix<Expr, OpMul, Expr>,
  #[precedence(level="3")] #[assoc(side="left")]
	Infix<Expr, OpAdd, Expr>,
  #[precedence(level="4")] #[assoc(side="left")]
	Infix<Expr, OpShift, Expr>,
  #[precedence(level="5")] #[assoc(side="left")] 
	Infix<Expr, OpComp, Expr>,
  #[precedence(level="6")] #[assoc(side="left")]
	Infix<Expr, OpEq, Expr>,
  #[precedence(level="7")] #[assoc(side="left")]
	Infix<Expr, OpAnd, Expr>,
  #[precedence(level="8")] #[assoc(side="left")]
	Infix<Expr, OpXor, Expr>,
  #[precedence(level="9")] #[assoc(side="left")]
	Infix<Expr, OpOr, Expr>,
  #[precedence(level="10")] #[assoc(side="left")]
	Infix<Expr, OpBoolAnd, Expr>,
  #[precedence(level="11")] #[assoc(side="left")]
	Infix<Expr, OpBoolOr, Expr>,
};

ExprTerm: Expr = {
	ExprVarnode,
	ExprBitRange,
	"(" <Expr> ")" => Expr::Paren(ctx.add(<>)),
};

OpBoolOr: BinaryOp = "||" => BinaryOp::Or;
OpBoolAnd: BinaryOp = {
	"&&" => BinaryOp::And,
	"^^" => BinaryOp::Xor,
};

OpOr: BinaryOp = "|" => BinaryOp::LogOr;
OpXor: BinaryOp = "^" => BinaryOp::LogXor;
OpAnd: BinaryOp = "&" => BinaryOp::LogAnd;

OpEq: BinaryOp = {
	"==" => BinaryOp::Equal,
	"!=" => BinaryOp::NotEqual,
	"f==" => BinaryOp::FloatEqual,
	"f!=" => BinaryOp::FloatNotEqual,
};

OpComp: BinaryOp = {
	"<"	 => BinaryOp::Less,
	">" => BinaryOp::Greater,
	"<="	 => BinaryOp::LessEqual,
	">=" => BinaryOp::GreaterEqual,
	"s<"	 => BinaryOp::SignedLess,
	"s>" => BinaryOp::SignedGreater,
	"s<="	 => BinaryOp::SignedLessEqual,
	"s>=" => BinaryOp::SignedGreaterEqual,
	"f<"	 => BinaryOp::FloatLess,
	"f>" => BinaryOp::FloatGreater,
	"f<="	 => BinaryOp::FloatLessEqual,
	"f>=" => BinaryOp::FloatGreaterEqual,
};

OpShift: BinaryOp = {
	"<<" => BinaryOp::ShiftLeft,
	">>" => BinaryOp::ShiftRight,
	"s>>" => BinaryOp::SignedShiftRight,
}

OpAdd: BinaryOp = {
	"+" => BinaryOp::Plus,
	"-" => BinaryOp::Minus,
	"f+" => BinaryOp::FloatPlus,
	"f-" => BinaryOp::FloatMinus,
};

OpMul: BinaryOp = {
	"*" => BinaryOp::Mul,
	"/" => BinaryOp::Div,
	"%"	=> BinaryOp::Mod,
	"s/" => BinaryOp::SignedDiv,
	"s%"	=> BinaryOp::SignedMod,
	"f*" => BinaryOp::FloatMul,
	"f/" => BinaryOp::FloatDiv,
};

OpUnary: UnaryOp = {
	"!" => UnaryOp::Not,
	"~" => UnaryOp::Inv,
	"-" => UnaryOp::Neg,
	"f-" => UnaryOp::FloatNeg,
};

//
 
ConstructorContext: Vec<Expr> = "["	<ContextStatement*> "]";

ContextStatement: Expr = {
	<Assignment> ";",
	<FunCall> ";",
};

ConstructorBody: Vec<Expr> = "{" <Statement*> "}";

pub Macro: Macro = {
	"macro" <id:Ident> "(" <args:ArgNames> ")" "{" <body:Statement+> "}" =>
		Macro { id, args, body: ctx.add_many(body) }
};

pub Statement: Expr = {
	<Label> => Expr::Id(<>),
	<Assignment> ";",
	<Declaration> ";",
	<FunCall> ";",
	<Build> ";",
	<Goto> ";",
	<Branch> ";",
	<Call> ";",
	<Export> ";",
	<Return> ";",
};

pub Assignment: Expr = {
	"local" <lhs:LValue> "=" <rhs:Expr> =>
		Expr::Bind { lhs: ctx.add(lhs), rhs: ctx.add(rhs) },
	<lhs:LValue> "=" <rhs:Expr> =>
		Expr::Bind { lhs: ctx.add(lhs), rhs: ctx.add(rhs) },
};

pub Declaration: Expr = {
	"local" <id:ExprIdent> ":" <size:Number> => {
		let rhs = Expr::Sized { expr: ctx.add(Expr::Unit), size };
		Expr::Bind { lhs: ctx.add(id), rhs: ctx.add(rhs)}
	},
	"local" <id:ExprIdent> => {
		Expr::Bind { lhs: ctx.add(id), rhs: ctx.add(Expr::Unit) }
	}
		
};

pub Build: Expr = {
	"build" <Ident> => Expr::Build(<>),
};

pub FunCall: Expr = {
	<id:Ident> "("	<args:Args> ")" =>
		Expr::FunCall { id, args: ctx.add_many(args) }
};

pub Goto: Expr = {
	"goto" <target:JumpTarget> => Expr::Goto(<>),
};

pub Branch: Expr = {
	"if" <expr:Expr> "goto" <target:JumpTarget> => {
		let condition = ctx.add(expr);
		Expr::Branch { condition, target }
	},
};

pub Call: Expr = {
	"call" <JumpTarget> => Expr::Call(<>),
};

pub Export: Expr = {
	"export" <ExprVarnode> => Expr::Export(ctx.add(<>)),
	"export" <SizedPointer<ExprIdent>> => Expr::Export(ctx.add(<>)),
};

pub Return: Expr = {
	"return" "[" <JumpTarget> "]" => Expr::Return(<>),
};

pub JumpTarget: JumpTarget = {
	<address:Number> "[" <space:Ident> "]" =>
		JumpTarget::Fixed{ address, space: Some(space) },
	<address:Number> =>
		JumpTarget::Fixed{ address, space: None },
	<Ident> =>
		JumpTarget::Direct(<>),
	"[" <Expr> "]" => {
		let expr = ctx.add(<>);
		JumpTarget::Indirect(expr)
	},
	<Label> => JumpTarget::Label(<>),
};

LValue: Expr = {
	<ExprBitRange>,
	<id:ExprIdent> ":" <size:Number> => 
		Expr::Sized { expr: ctx.add(id), size },
	<ExprIdent>,
	SizedPointer<Expr>,
};

ExprBitRange: Expr = {
	<id:Ident> "[" <start_bit:Number> "," <width:Number> "]" =>
		Expr::BitRange { id, start_bit, width }
};

pub ExprVarnode: Expr = {
	<ExprNumber>,
	<ExprIdent>,
	<id:ExprIdent> ":" <size:Number> => 
		Expr::Sized { expr: ctx.add(id), size },
	<n:ExprNumber> ":" <size:Number> => 
		Expr::Sized { expr: ctx.add(n), size },
};

pub Label: Loc<Ident> = "<" <Ident> ">";
pub ExprIdent: Expr = <Ident> => Expr::Id(<>);
pub ExprNumber: Expr = <Number> => Expr::Int(<>);

pub ArgNames: Vec<Loc<Ident>> = Sep<Ident, ",">;
pub Args: Vec<Expr> = Sep<Expr, ",">;

SizedPointer<T>: Expr = {
	"*" "[" <space:Ident> "]" ":" <size:Number> <expr:T> => {
		let expr = ctx.add(expr);
		let ptr = Expr::Pointer { expr, space: Some(space) };
		let ptr = ctx.add(ptr);
		Expr::Sized { expr, size }
	},
	"*" "[" <space:Ident> "]" <expr:T> => {
		let expr = ctx.add(expr);
		Expr::Pointer { expr, space: Some(space) }
	},
	"*" ":" <size:Number> <expr:T> => {
		let expr = ctx.add(expr);
		let ptr = Expr::Pointer { expr, space: None };
		let ptr = ctx.add(ptr);
		Expr::Sized { expr, size }
	},
	"*" <expr:T> => {
		let expr = ctx.add(expr);
		Expr::Pointer { expr, space: None }
	},
};

extern {
	type Location = usize;
	type Error = ParseError;

	enum T<'input> {
    "alignment" => T::Normal(NT::Alignment),
    "attach" => T::Normal(NT::Attach),
    "big" => T::Normal(NT::Big),
    "bin int" => T::Normal(NT::BinInt(<usize>)),
    "dec int" => T::Normal(NT::DecInt(<usize>)),
    "hex int" => T::Normal(NT::HexInt(<usize>)),
    "ident" => T::Normal(NT::Ident(<&'input str>)),
    "display ident" => T::Display(DT::Ident(<&'input str>)),
    "is" => T::Display(DT::Is),
    "if" => T::Normal(NT::If),
    "register" => T::Normal(NT::Register),
    "register space" => T::Normal(NT::RegisterSpace),
    "default" => T::Normal(NT::Default),
    "little" => T::Normal(NT::Little),
    "build" => T::Normal(NT::Build),
    "call" => T::Normal(NT::Call),
    "dec" => T::Normal(NT::Dec),
    "define" => T::Normal(NT::Define),
    "endian" => T::Normal(NT::Endian),
    "export" => T::Normal(NT::Export),
    "goto" => T::Normal(NT::Goto),
    "hex" => T::Normal(NT::Hex),
    "local" => T::Normal(NT::Local),
    "macro" => T::Normal(NT::Macro),
  	"offset" => T::Normal(NT::Offset),
    "pcodeop" => T::Normal(NT::PCodeOp),
		"ram space" =>  T::Normal(NT::RamSpace),
		"rom space" =>  T::Normal(NT::RomSpace),
    "return" => T::Normal(NT::Return),
    "signed" => T::Normal(NT::Signed),
	  "size" => T::Normal(NT::Size),
	  "space" => T::Normal(NT::Space),
    "token" => T::Normal(NT::Token),
    "type" => T::Normal(NT::Type),
    "unimpl" => T::Normal(NT::Unimpl),
    "variables" => T::Normal(NT::Variables),
	  "word size" => T::Normal(NT::WordSize),
    "..." => T::Normal(NT::Ellipsis),
    "{" => T::Normal(NT::LBrace),
    "}" => T::Normal(NT::RBrace),
    "[" => T::Normal(NT::LBracket),
    "]" => T::Normal(NT::RBracket),
    "(" => T::Normal(NT::LParen),
    ")" => T::Normal(NT::RParen),
    ":" => T::Normal(NT::Colon),
    "," => T::Normal(NT::Comma),
    "!" => T::Normal(NT::Bang),
    "~" => T::Normal(NT::Tilde),
    "," => T::Normal(NT::Comma),
    ";" => T::Normal(NT::Semi),
    "=" => T::Normal(NT::Assign),
    "<" => T::Normal(NT::LT),
    ">" => T::Normal(NT::GT),
    "==" => T::Normal(NT::EQ),
    "!=" => T::Normal(NT::NE),
    "<=" => T::Normal(NT::LE),
    ">=" => T::Normal(NT::GE),
    "||" => T::Normal(NT::Or),
    "&&" => T::Normal(NT::And),
    "^^" => T::Normal(NT::Xor),
    "|" => T::Normal(NT::Pipe),
    "&" => T::Normal(NT::Ampersand),
    "^" => T::Normal(NT::Caret),
    "<<" => T::Normal(NT::LShift),
    ">>" => T::Normal(NT::RShift),
    "+" => T::Normal(NT::Plus),
    "-" => T::Normal(NT::Minus),
    "*" => T::Normal(NT::Star),
    "/" => T::Normal(NT::Slash),
    "%" => T::Normal(NT::Percent),
    "$or" => T::Normal(NT::SpecOr),
    "$and" => T::Normal(NT::SpecAnd),
    "$xor" => T::Normal(NT::SpecXor),
    "f<" => T::Normal(NT::FLT),
    "f>" => T::Normal(NT::FGT),
    "f==" => T::Normal(NT::FEQ),
    "f!=" => T::Normal(NT::FNE),
    "f<=" => T::Normal(NT::FLE),
    "f>=" => T::Normal(NT::FGE),
    "f+" => T::Normal(NT::FPlus),
    "f-" => T::Normal(NT::FMinus),
    "f*" => T::Normal(NT::FMul),
    "f/" => T::Normal(NT::FDiv),
    "s<" => T::Normal(NT::SLT),
    "s>" => T::Normal(NT::SGT),
    "s<=" => T::Normal(NT::SLE),
    "s>=" => T::Normal(NT::SGE),
    "s<<" => T::Normal(NT::SLShift),
    "s>>" => T::Normal(NT::SRShift),
    "s/" => T::Normal(NT::SDiv),
    "s%" => T::Normal(NT::SMod),
    "caret" => T::Display(DT::Caret),
    "text" => T::Display(DT::Text(<&'input str>)),
		" " => T::Display(DT::Whitespace),
	}
}
