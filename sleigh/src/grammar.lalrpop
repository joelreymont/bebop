use super::{
	ast::*,
	error::ParseError,
	lexer::{Token as T, NormalToken as NT, DisplayToken as DT},
	meta::*,
};

grammar<'input>(file_id: FileId);

/*
%left PIPE
%left AMPERSAND
%left OR SPEC_OR
%left CARET XOR SPEC_XOR
%left AND SPEC_AND 
%nonassoc EQUAL NOT_EQUAL FLOAT_EQUAL FLOAT_NOT_EQUAL
%nonassoc LESS_THAN GREATER_THAN LESS_EQUAL GREATER_EQUAL
          SIGNED_LESS_THAN SIGNED_GREATER_THAN SIGNED_LESS_EQUAL
		  SIGNED_GREATER_EQUAL FLOAT_LESS_THAN FLOAT_GREATER_THAN
		  FLOAT_LESS_EQUAL FLOAT_GREATER_EQUAL
%left SHIFT_LEFT SHIFT_RIGHT SIGNED_SHIFT_RIGHT SIGNED_SHIFT_LEFT
%left PLUS MINUS FLOAT_MINUS FLOAT_PLUS
%left STAR SLASH PERCENT FLOAT_DIV FLOAT_MUL SIGNED_DIV SIGNED_MOD
%nonassoc UNARY
*/
Located<T>: Loc<T> = <left: @L> <node: T> <right: @R> =>
	Loc::new(node, Span::new(file_id, left..right));

pub Ident: Loc<Ident> = {
	Located<"ident"> => <>.map(Ident::new),
};

pub Defs: Vec<Definition> = <Def+> => <>;

pub Def: Definition = {
	Located<EndianDef> => Definition::Endian(<>),
	Located<AlignmentDef> => Definition::Alignment(<>),
	Located<SpaceDef> => Definition::Space(<>),
	Located<VarnodeDef> => Definition::Varnode(<>),
	Located<TokenDef> => Definition::Token(<>),
};

pub EndianDef: Endian = {
	"define" "endian" "=" <Endian> ";" => <>
};

pub Endian: Endian = {
	"big" => Endian::Big,
	"little" => Endian::Little,
}

pub AlignmentDef: usize = {
	"define" "alignment" "=" <Number> ";" => <>
};

pub Number: usize = {
	"dec int" => <>,
	"hex int" => <>,
	"bin int" => <>,
};

pub SpaceDef: Space = {
	"define" "space" <id:Ident> <kind:SpaceKind> <mods:SpaceMod+> ";" =>
		Space::new(id, kind, mods),
	"define" "space" <id:Located<"register">> <kind:SpaceKind> <mods:SpaceMod+> ";" =>
		Space::new(id.map(|_| Ident::new("register")), kind, mods),
};

pub SpaceKind: SpaceKind = {
  "type" "=" <space_kind> => <>,
};

space_kind: SpaceKind = {
	"rom space" => SpaceKind::Rom,
	"ram space" => SpaceKind::Ram,
	"register space" => SpaceKind::Register,
};

SpaceMod: SpaceMod = {
	"size" "=" <Number> => SpaceMod::Size(<>),
	"word size" "=" <Number> => SpaceMod::WordSize(<>),
	"default" => SpaceMod::IsDefault,
};

pub VarnodeDef: Varnode = {
	"define" "register" <mods:VarnodeMod+> "[" <ids:Ident+> "]" ";" =>
		Varnode::new(ids, mods),
};

VarnodeMod: VarnodeMod = {
	"size" "=" <Number> => VarnodeMod::Size(<>),
	"offset" "=" <Number> => VarnodeMod::Offset(<>),
};

pub TokenDef: Token = {
	"define" "token" <id:Ident> "(" <bit_width:Number> ")" <fields:TokenField+> ";" =>
		Token {id, bit_width, fields},
};

pub TokenField: Field = {
	<id:Ident> "=" "(" <start:Number> "," <end:Number> ")" <mods:TokenFieldMod*> =>
		Field::new(id, start, end, mods),
};

pub TokenFieldMod: FieldMod = {
	"signed" => FieldMod::IsSigned,
	"hex" => FieldMod::IsHex,
};
/*
token_field:
	id ASSIGN LPAREN constant COMMA constant RPAREN token_field_mod*
		{ Token_field.make ~id:$1 ~start_bit:$4 ~end_bit:$6 ~mods:$8 }

token_field_mod:
	| signed { Token_field.Signed $1 }
	| hex    { Token_field.Hex $1 }

definition:
	| definition_semi SEMI { $1 }
	| constructor          { Definition.Constructor $1 }
	| macro                { Definition.Macro $1 }
	
definition_semi:
	| token_definition          { Definition.Token $1 }
	| varnode_attach_definition { Definition.Varnode_attach $1 }
	| pcodeop_definition        { Definition.Pcode_op $1 }

varnode_attach_definition:
	varnode_attach_start KEY_VARIABLES LBRACKET id+ RBRACKET LBRACKET id+ RBRACKET
		{ Varnode_attach.make ~pos:(Position.position $1) ~fields:$4 ~registers:$7 }

varnode_attach_start:
	KEY_ATTACH { Position.with_poss $startpos $endpos () }

pcodeop_definition:
	KEY_DEFINE KEY_PCODEOP id { $3 }

constructor:
	| id midrule(display_lexer_on) COLON display pattern context constructor_body
		{ Constructor.{id = $1; display = $4; pattern = $5; context = $6; body = $7} }
	| COLON midrule(display_lexer_on) id display pattern context constructor_body
		{ Constructor.{id = $3; display = $4; pattern = $5; context = $6; body = $7} }

display:
	mnemonic output { Display.{mnemonic = $1; output = $2} }

mnemonic:
	display_piece* SPACE { $1 }

output:
	| output_piece* midrule(display_lexer_off) RES_IS { $1 }

display_piece:
	| CARET { Display.Caret }
	| id    { Display.Id $1 }
	| text  { Display.Text $1 }

output_piece:
	| CARET { Display.Caret }
	| SPACE { Display.Whitespace }
	| id    { Display.Id $1 }
	| text  { Display.Text $1 }

pattern:
	separated_list(SEMI, pattern_expr) { $1 }

context:
	| LBRACKET context_statement* RBRACKET { $2 }
	|                                      { [] }

constructor_body:
	| LBRACE semantic_body RBRACE     { $2 }
	|                      KEY_UNIMPL { [] }

context_statement: 
	| assignment SEMI { $1 }
	| funcall SEMI    { $1 }

pattern_expr: 
	| pattern_expr pattern_op pattern_expr { Pattern.Binary ($1, $2, $3) }
	| ELLIPSIS pattern_atomic              { Pattern.Align_right $2 }
	| pattern_atomic ELLIPSIS              { Pattern.Align_left $1 }
	| pattern_atomic                       { $1 }
	 
%inline pattern_op:
	| PIPE      { Pattern.OR }
	| AMPERSAND { Pattern.AND }

pattern_atomic:
	| condition                  { Pattern.Constraint $1 }
	| LPAREN pattern_expr RPAREN { Pattern.Paren $2 }

condition:
	| id                             { Symbol $1 }
	| id condition_op condition_expr { Condition ($1, $2, $3) }

condition_expr:
	| condition_expr condition_expr_op condition_expr    { Expr.Binary ($2, $1, $3) }
	| condition_expr_unary_op condition_expr %prec UNARY { Expr.Unary ($1, $2) }
	| id                                                 { Expr.Id $1 }
	| constant                                           { Expr.Int $1 }
	| LPAREN expr = condition_expr RPAREN                { Expr.Paren expr }

semantic_body:
	statement* { $1 }
	
macro:
	KEY_MACRO id LPAREN arg_names RPAREN macro_body
		{ Macro.{id = $2; args = $4; body = $6} }

macro_body:
	| LBRACE semantic_body RBRACE { $2 }

statement:
	| label          { Statement.Label $1 }
	| non_label SEMI { $1 }
	
non_label: 
	| assignment  { $1 }
	| declaration { $1 }
	| funcall     { $1 }
	| build       { $1 }
	| goto        { $1 }
	| branch      { $1 }
	| call        { $1 }
	| export      { $1 }
	| return      { $1 }

assignment:
	| KEY_LOCAL lvalue ASSIGN expr { Statement.Assign ($2, $4) }
	| lvalue ASSIGN expr           { Statement.Assign ($1, $3) }

declaration:
	| KEY_LOCAL id COLON constant { Statement.Declare ($2, Some $4) }
	| KEY_LOCAL id                { Statement.Declare ($2, None) }

build:
	| KEY_BUILD id { Statement.Build $2 }

funcall:
	| id LPAREN args RPAREN { Statement.Fun_call ($1, $3) }

goto:
	| KEY_GOTO jump_target { Statement.Goto $2 }

branch:
	| RES_IF expr KEY_GOTO jump_target { Statement.Branch ($2, $4) }

call:
	| KEY_CALL jump_target { Statement.Call $2 }
	
export:
	| KEY_EXPORT sized_export { Statement.Export $2 }
	| KEY_EXPORT varnode      { Statement.Export $2 }

return:
	| KEY_RETURN LBRACKET jump_target RBRACKET { Statement.Return $3 }

label:
	| LESS_THAN id GREATER_THAN { $2 }

jump_target:
	| constant LBRACKET id RBRACKET { Jump_target.Fixed ($1, Some $3) }
	| constant                      { Jump_target.Fixed ($1, None) }
	| id                            { Jump_target.Direct $1 }
	| LBRACKET expr RBRACKET        { Jump_target.Indirect $2 }
	| label                         { Jump_target.Label $1 }

lvalue:
	| bitrange            { $1 }
	| id COLON constant   { Expr.Sized (Expr.Id $1, $3) }
	| id                  { Expr.Id $1 }
	| sized_pointer(expr) { $1 }
	
expr:
	| expr expr_op expr         { Expr.Binary ($2, $1, $3) }
	| expr_unary_op expr_unary  { Expr.Unary ($1, $2) }
	| sized_pointer(expr_unary) { $1 }
	| expr_unary                { $1 }

expr_unary:
	| expr_funcall { $1 }
	| expr_term    { $1 }

expr_term:
	| LPAREN expr RPAREN { Expr.Paren $2 }
	| varnode            { $1 }
	| bitrange           { $1 }

expr_funcall:
	id LPAREN args RPAREN { Expr.Fun_call ($1, $3) }

varnode:
	| constant                { Expr.Int $1 }
	| id                      { Expr.Id $1 }
	| id COLON constant       { Expr.Sized (Expr.Id $1, $3) }
	| constant COLON constant { Expr.Sized (Expr.Int $1, $3) }

bitrange:
	id LBRACKET constant COMMA constant RBRACKET
		{ Expr.Bit_range ($1, $3, $5) }

sized_export:
	| sized_pointer(id_expr) { $1 }

id_expr:
	| id { Expr.Id $1 }

%inline sized_pointer(X):
	| STAR LBRACKET id RBRACKET COLON constant X { Expr.Sized (Expr.Pointer ($7, Some $3), $6) }
	| STAR LBRACKET id RBRACKET X                { Expr.Pointer ($5, Some $3) }
	| STAR COLON constant X                      { Expr.Sized (Expr.Pointer ($4, None), $3) }
	| STAR X                                     { Expr.Pointer ($2, None) }

args:
	separated_list(COMMA, expr) { $1 }

arg_names:
	separated_list(COMMA, id) { $1 }

%inline condition_op:
	| ASSIGN        { Pattern.EQ }
	| NOT_EQUAL     { Pattern.NE }
	| LESS_THAN     { Pattern.LT}
	| LESS_EQUAL    { Pattern.LE }
	| GREATER_THAN  { Pattern.GT }
	| GREATER_EQUAL { Pattern.GE }

%inline condition_expr_op:
	| SPEC_OR     { Expr.OR }
	| SPEC_AND    { Expr.AND }
	| SPEC_XOR    { Expr.XOR }
	| SHIFT_LEFT  { Expr.LSHIFT }
	| SHIFT_RIGHT { Expr.RSHIFT }
	| PLUS        { Expr.PLUS }
	| MINUS       { Expr.MINUS }

condition_expr_unary_op:
	| MINUS { Expr.NEG }
	| TILDE { Expr.INV }

expr_unary_op:
	| MINUS { Expr.NEG }
	| TILDE { Expr.INV }
	| BANG  { Expr.NOT }

%inline expr_op:
	| OR                   { Expr.BOR }
	| AND                  { Expr.BAND }
	| XOR                  { Expr.BXOR }
	| AMPERSAND            { Expr.AND }
	| PIPE                 { Expr.OR }
	| CARET                { Expr.XOR }
	| EQUAL                { Expr.EQ }
	| NOT_EQUAL            { Expr.NE }
	| LESS_THAN            { Expr.LT }
	| GREATER_THAN         { Expr.GT }
	| LESS_EQUAL           { Expr.LE }
	| GREATER_EQUAL        { Expr.GE }
	| SHIFT_LEFT           { Expr.LSHIFT }
	| SHIFT_RIGHT          { Expr.RSHIFT }
	| PLUS                 { Expr.PLUS }
	| MINUS                { Expr.MINUS }
	| STAR                 { Expr.MUL }
	| SLASH                { Expr.DIV }
	| PERCENT              { Expr.MOD }
	| SIGNED_DIV           { Expr.SDIV }
	| SIGNED_MOD           { Expr.SMOD }
	| SIGNED_SHIFT_LEFT    { Expr.SLSHIFT }
	| SIGNED_SHIFT_RIGHT   { Expr.SRSHIFT }
	| SIGNED_GREATER_EQUAL { Expr.SGE }
	| SIGNED_LESS_EQUAL    { Expr.SLE }
	| SIGNED_GREATER_THAN  { Expr.SGT }
	| SIGNED_LESS_THAN     { Expr.SLT }
	| FLOAT_EQUAL          { Expr.FEQ }
	| FLOAT_NOT_EQUAL      { Expr.FNE }
	| FLOAT_DIV            { Expr.FDIV }
	| FLOAT_MUL            { Expr.FMUL }
	| FLOAT_MINUS          { Expr.FMINUS }
	| FLOAT_PLUS           { Expr.FPLUS }
    | FLOAT_GREATER_EQUAL  { Expr.FGE }
	| FLOAT_GREATER_THAN   { Expr.FGT }
    | FLOAT_LESS_EQUAL     { Expr.FLE }
	| FLOAT_LESS_THAN      { Expr.FLT }

space_is_default:
	| KEY_DEFAULT { true }

id:
	located(ID) { $1 }

text:
	located(TEXT) { $1 }

%inline located(X):
	x=X { Tag.with_pos Position.(lex_join $startpos $endpos) x }

constant:
	| located(integer) { $1 }

integer:
	| DEC_INT { $1 }
	| HEX_INT { $1 }
	| BIN_INT { $1 }

signed:
	| KEY_SIGNED { true }

hex:
	| KEY_HEX { true }
	| KEY_DEC { false }

display_lexer_on:
	| { display_lexer_on() }

display_lexer_off:
	| { display_lexer_off() }

*/

extern {
	type Location = usize;
	type Error = ParseError;

	enum T<'input> {
    "alignment" => T::Normal(NT::Alignment),
    // "attach" => T::Normal(NT::Attach),
    "big" => T::Normal(NT::Big),
    "bin int" => T::Normal(NT::BinInt(<usize>)),
    "dec int" => T::Normal(NT::DecInt(<usize>)),
    "hex int" => T::Normal(NT::HexInt(<usize>)),
    "ident" => T::Normal(NT::Ident(<&'input str>)),
    // "is" => T::Normal(NT::Is),
    // "if" => T::Normal(NT::If),
    "register" => T::Normal(NT::Register),
    "register space" => T::Normal(NT::RegisterSpace),
    "default" => T::Normal(NT::Default),
    "little" => T::Normal(NT::Little),
    // "build" => T::Build,
    // "call" => T::Call,
    // "dec" => T::Dec,
    "define" => T::Normal(NT::Define),
    "endian" => T::Normal(NT::Endian),
  //   "export" => T::Export,
  //   "goto" => T::Goto,
    "hex" => T::Normal(NT::Hex),
  //   "local" => T::Local,
  //   "macro" => T::Macro,
  	"offset" => T::Normal(NT::Offset),
  //   "pcodeop" => T::PCodeOp,
		"ram space" =>  T::Normal(NT::RamSpace),
		"rom space" =>  T::Normal(NT::RomSpace),
  //   "return" => T::Return,
    "signed" => T::Normal(NT::Signed),
	"size" => T::Normal(NT::Size),
	"space" => T::Normal(NT::Space),
    "token" => T::Normal(NT::Token),
    "type" => T::Normal(NT::Type),
    //"unimpl" => T::Unimpl,
	"word size" => T::Normal(NT::WordSize),
    // "..." => T::Ellipsis,
    // "{" => T::LBrace,
    // "}" => T::RBrace,
    "[" => T::Normal(NT::LBracket),
    "]" => T::Normal(NT::RBracket),
    "(" => T::Normal(NT::LParen),
    ")" => T::Normal(NT::RParen),
    // ":" => T::Colon,
    // "," => T::Comma,
    // "!" => T::Bang,
    // "~" => T::Tilde,
    "," => T::Normal(NT::Comma),
    ";" => T::Normal(NT::Semi),
    "=" => T::Normal(NT::Assign),
    // "<" => T::LT,
    // ">" => T::GT,
    // "==" => T::EQ,
    // "!=" => T::NE,
    // "<=" => T::LE,
    // ">=" => T::GE,
    // "||" => T::Or,
    // "&&" => T::And,
    // "^^" => T::Xor,
    // "|" => T::Pipe,
    // "&" => T::Ampersand,
    // "^" => T::Caret,
    // "<<" => T::LShift,
    // ">>" => T::RShift,
    // "+" => T::Plus,
    // "-" => T::Minus,
    // "*" => T::Star,
    // "/" => T::Slash,
    // "% "=> T::Percent,
    // "$or" => T::SpecOr,
    // "$and" => T::SpecAnd,
    // "$xor" => T::SpecXor,
    // "f<" => T::FLT,
    // "f>" => T::FGT,
    // "f==" => T::FEQ,
    // "f!=" => T::FNE,
    // "f<=" => T::FLE,
    // "f>=" => T::FGE,
    // "f+" => T::FPlus,
    // "f-" => T::FMinus,
    // "f*" => T::FMul,
    // "f/" => T::FDiv,
    // "s<" => T::SLT,
    // "s>" => T::SGT,
    // "s<=" => T::SLE,
    // "s>=" => T::SGE,
    // "s<<" => T::SLShift,
    // "s>>" => T::SRShift,
    // "s/" => T::SDiv,
    // "s%" => T::SMod,
	}
}
