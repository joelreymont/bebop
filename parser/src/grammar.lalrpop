use bebop_util::{meta::*, id::*};
use super::{
	ast::*,
	error::ParserError,
	lexer::{Token as T, NormalToken as NT, DisplayToken as DT},
};

grammar<'input>();

Located<T>: Loc<T> = <left: @L> <node: T> <right: @R> =>
	Loc::new(node, (left..right).into());

Sep<T, S>: Vec<T> = {
    <mut v:(<T> S)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Infix<L, Op, R>: Expr = {
    <lhs:L> <op:Op> <rhs:R> =>
			Expr::Binary { op, lhs: Box::new(lhs), rhs: Box::new(rhs) },
};

pub Ident: LocId = {
	Located<"ident"> => LocId::from(<>.map(Id::new)),
};

pub DisplayIdent: LocId = {
	Located<"display ident"> => LocId::from(<>.map(Id::new)),
};

pub Defs: Vec<Definition> = <Def+>;

pub Def: Definition = {
	Located<EndianDef> => Definition::Endian(<>),
	AlignmentDef => Definition::Alignment(<>),
	SpaceDef => Definition::Space(<>),
	Located<VarnodeDef> => Definition::Varnode(<>),
	TokenDef => Definition::Token(<>),
	Located<VarnodeAttachDef> => Definition::VarnodeAttach(<>),
	Macro => Definition::Macro(<>),
	Constructor => Definition::Constructor(<>),
	PCodeOp => Definition::PCodeOp(<>),
};

pub EndianDef: Endian = "define" "endian" "=" <Endian> ";";

pub Endian: Endian = <Ident> =>? Endian::parse(<>);

pub AlignmentDef: Loc<usize> = "define" "alignment" "=" <Number> ";";

pub Number: Loc<usize> = {
	Located<"dec int">,
	Located<"hex int">,
	Located<"bin int">,
};

pub SpaceDef: Space = {
	"define" "space" <id:Ident> <kind:SpaceKind> <mods:SpaceMod+> ";" =>
		Space::new(id, kind, mods),
	"define" "space" <id:Located<"register">> <kind:SpaceKind> <mods:SpaceMod+> ";" =>
		Space::new(LocId::from(id.map(|_| Id::new("register"))), kind, mods),
};

pub SpaceKind: SpaceKind = "type" "=" <Ident> =>? {
	SpaceKind::parse(<>)
};

SpaceMod: SpaceMod = {
	<id:Ident> "=" <num:Number> =>? SpaceMod::parse(id, Some(num)),
	<Ident> =>? SpaceMod::parse(<>, None),
};

pub VarnodeDef: Varnode = {
	"define" "register" <mods:VarnodeMod+> "[" <ids:Ident+> "]" ";" =>
		Varnode::new(ids, mods),
};

VarnodeMod: VarnodeMod = {
	<id:Ident> "=" <num:Number> =>? VarnodeMod::parse(id, num),
};

pub TokenDef: Token = {
	"define" "token" <id:Ident> "(" <bit_width:Number> ")" <fields:TokenField+> ";" =>
		Token {id, bit_width, fields},
};

pub TokenField: Field = {
	<id:Ident> "=" "(" <start:Number> "," <end:Number> ")" <mods:TokenFieldMod*> =>
		Field::new(id, start, end, mods),
};

pub TokenFieldMod: FieldMod = {
	"signed" => FieldMod::IsSigned,
	"hex" => FieldMod::IsHex,
};

pub VarnodeAttachDef: VarnodeAttach = {
	"attach" "variables" "[" <fields:Ident+> "]" "[" <registers:Ident+> "]" ";" =>
		VarnodeAttach { fields, registers }
};

pub Constructor: Constructor = {
	<start:ConstructorStart> <end:ConstructorEnd> => {
		let (id, display, is_instruction) = start;
		let (pattern, context, body) = end;
		Constructor { id, display, pattern, context, body, is_instruction }
	},
};

pub ConstructorStart: (LocId, Display, bool) = {
	<i:Ident> ":" <d:Display> "is" => (i, d, false),
	":" <i:DisplayIdent> <d:Display> "is" => (i, d, true),
};

pub ConstructorEnd: (Option<Expr>, Vec<Statement>, Vec<Statement>) = {
	<p:Pattern?> "unimpl" => (p, Vec::new(), Vec::new()),
	<p:Pattern?> <c:ConstructorContext> "unimpl" => (p, c, Vec::new()),
	<p:Pattern?> <b:ConstructorBody> => (p, Vec::new(), b),
	<p:Pattern?> <c:ConstructorContext> <b:ConstructorBody> => (p, c, b),
};

pub Display: Display = {
	<mnemonic:Mnemonic> <output:Output> => Display { mnemonic, output },
};

pub Mnemonic: Vec<DisplayPiece> = <MnemonicPiece*> " ";

pub Output: Vec<DisplayPiece> = <OutputPiece*>;

pub MnemonicPiece: DisplayPiece = {
	"caret" => DisplayPiece::Caret,
	<DisplayIdent> => DisplayPiece::Id(<>),
	<"text"> => DisplayPiece::Text(Id::new(<>)),
}

pub OutputPiece: DisplayPiece = {
	"caret" => DisplayPiece::Caret,
	" " => DisplayPiece::Space,
	<DisplayIdent> => DisplayPiece::Id(<>),
	<"text"> => DisplayPiece::Text(Id::new(<>)),
}

//
// Bit pattern
//

pub Pattern: Expr = {
  #[precedence(level="0")]
	<op:Located<"...">> <pat:PatAtomic> =>
		Expr::Unary { op: op.map(|_| UnaryOp::AlignRight), rhs: Box::new(pat) },
	<pat:PatAtomic> <op:Located<"...">> =>
		Expr::Unary { op: op.map(|_| UnaryOp::AlignLeft), rhs: Box::new(pat) },
	PatAtomic,
  #[precedence(level="1")] #[assoc(side="left")]
	Infix<Pattern, OpPatAnd, Pattern>,
  #[precedence(level="2")] #[assoc(side="left")]
	Infix<Pattern, OpPatSeq, Pattern>,
  #[precedence(level="2")] #[assoc(side="left")]
	Infix<Pattern, OpPatOr, Pattern>,
};

PatAtomic: Expr = {
	<ExprIdent>,
	<lhs:ExprIdent> <op:PatCondOp> <rhs:PatExpr> =>
		Expr::Binary { op, lhs: Box::new(lhs), rhs: Box::new(rhs) },
	"(" <Pattern> ")" => Expr::Paren(Box::new(<>)),
};

OpPatOr: Loc<BinaryOp> = Located<"|"> => <>.map(|_| BinaryOp::OR);
OpPatSeq: Loc<BinaryOp> = Located<";"> => <>.map(|_| BinaryOp::JOIN);
OpPatAnd: Loc<BinaryOp> = Located<"&"> => <>.map(|_| BinaryOp::AND);

PatCondOp: Loc<BinaryOp> = {
	Located<"="> => <>.map(|_| BinaryOp::EQ),
	Located<"!="> => <>.map(|_| BinaryOp::NE),
	Located<"<"> => <>.map(|_| BinaryOp::LT),
	Located<">"> => <>.map(|_| BinaryOp::GT),
	Located<"<="> => <>.map(|_| BinaryOp::LE),
	Located<">="> => <>.map(|_| BinaryOp::GE),
};

pub PatExpr: Expr = {
  #[precedence(level="0")]
	FunCall,
	PatExprTerm,
  #[precedence(level="1")]
	<op:PatExprOpUnary> <expr:PatExpr> => Expr::Unary { op, rhs: Box::new(expr) },
  #[precedence(level="2")] #[assoc(side="left")]
	Infix<PatExpr, PatExprOpMul, PatExpr>,
  #[precedence(level="3")] #[assoc(side="left")]
	Infix<PatExpr, PatExprOpAdd, PatExpr>,
  #[precedence(level="4")] #[assoc(side="left")]
	Infix<PatExpr, PatExprOpShift, PatExpr>,
  #[precedence(level="4")] #[assoc(side="left")]
	Infix<PatExpr, PatExprOpAnd, PatExpr>,
  #[precedence(level="5")] #[assoc(side="left")]
	Infix<PatExpr, PatExprOpXor, PatExpr>,
  #[precedence(level="6")] #[assoc(side="left")]
	Infix<PatExpr, PatExprOpOr, PatExpr>,
};

PatExprTerm: Expr = {
	<ExprIdent>,
	<ExprNumber>,
	"(" <PatExpr> ")" => Expr::Paren(Box::new(<>)),
};

PatExprOpOr: Loc<BinaryOp> = Located<"$or"> => <>.map(|_| BinaryOp::LOR);
PatExprOpXor: Loc<BinaryOp> = Located<"$xor"> => <>.map(|_| BinaryOp::LXOR);
PatExprOpAnd: Loc<BinaryOp> = Located<"$and"> => <>.map(|_| BinaryOp::LAND);

PatExprOpShift: Loc<BinaryOp> = {
	Located<"<<"> => <>.map(|_| BinaryOp::LSHIFT),
	Located<">>"> => <>.map(|_| BinaryOp::RSHIFT),
};

PatExprOpAdd: Loc<BinaryOp> = {
	Located<"+"> => <>.map(|_| BinaryOp::PLUS),
	Located<"-"> => <>.map(|_| BinaryOp::MINUS),
};

PatExprOpMul: Loc<BinaryOp> = {
	Located<"*"> => <>.map(|_| BinaryOp::PLUS),
	Located<"/"> => <>.map(|_| BinaryOp::MINUS),
};

PatExprOpUnary: Loc<UnaryOp> = {
	Located<"-"> => <>.map(|_| UnaryOp::NEG),
	Located<"~"> => <>.map(|_| UnaryOp::INV),
};

//
// Expr
//

pub Expr: Expr = {
  #[precedence(level="0")]
	FunCall,
	ExprTerm,
  #[precedence(level="1")]
	<op:OpUnary> <expr:Expr> => Expr::Unary { op, rhs: Box::new(expr) },
	SizedPointer<Expr>,
  #[precedence(level="2")] #[assoc(side="left")]
	Infix<Expr, OpMul, Expr>,
  #[precedence(level="3")] #[assoc(side="left")]
	Infix<Expr, OpAdd, Expr>,
  #[precedence(level="4")] #[assoc(side="left")]
	Infix<Expr, OpShift, Expr>,
  #[precedence(level="5")] #[assoc(side="left")]
	Infix<Expr, OpComp, Expr>,
  #[precedence(level="6")] #[assoc(side="left")]
	Infix<Expr, OpEq, Expr>,
  #[precedence(level="7")] #[assoc(side="left")]
	Infix<Expr, OpAnd, Expr>,
  #[precedence(level="8")] #[assoc(side="left")]
	Infix<Expr, OpXor, Expr>,
  #[precedence(level="9")] #[assoc(side="left")]
	Infix<Expr, OpOr, Expr>,
  #[precedence(level="10")] #[assoc(side="left")]
	Infix<Expr, OpBoolAnd, Expr>,
  #[precedence(level="11")] #[assoc(side="left")]
	Infix<Expr, OpBoolOr, Expr>,
};

ExprTerm: Expr = {
	ExprVarnode,
	ExprBitRange,
	"(" <Expr> ")" => Expr::Paren(Box::new(<>)),
};

OpBoolOr: Loc<BinaryOp> = Located<"||"> => <>.map(|_| BinaryOp::OR);
OpBoolAnd: Loc<BinaryOp> = {
	Located<"&&"> => <>.map(|_| BinaryOp::AND),
	Located<"^^"> => <>.map(|_| BinaryOp::XOR),
};

OpOr: Loc<BinaryOp> = Located<"|"> => <>.map(|_| BinaryOp::LOR);
OpXor: Loc<BinaryOp> = Located<"^"> => <>.map(|_| BinaryOp::LXOR);
OpAnd: Loc<BinaryOp> = Located<"&"> => <>.map(|_| BinaryOp::LAND);

OpEq: Loc<BinaryOp> = {
	Located<"=="> => <>.map(|_| BinaryOp::EQ),
	Located<"!="> => <>.map(|_| BinaryOp::NE),
	Located<"f=="> => <>.map(|_| BinaryOp::FEQ),
	Located<"f!="> => <>.map(|_| BinaryOp::FNE),
};

OpComp: Loc<BinaryOp> = {
	Located<"<"> => <>.map(|_| BinaryOp::LT),
	Located<">"> => <>.map(|_| BinaryOp::GT),
	Located<"<="> => <>.map(|_| BinaryOp::LE),
	Located<">="> => <>.map(|_| BinaryOp::GE),
	Located<"s<"> => <>.map(|_| BinaryOp::SLT),
	Located<"s>"> => <>.map(|_| BinaryOp::SGE),
	Located<"s<="> => <>.map(|_| BinaryOp::SLE),
	Located<"s>="> => <>.map(|_| BinaryOp::SGE),
	Located<"f<"> => <>.map(|_| BinaryOp::FLT),
	Located<"f>"> => <>.map(|_| BinaryOp::FGT),
	Located<"f<="> => <>.map(|_| BinaryOp::FLE),
	Located<"f>="> => <>.map(|_| BinaryOp::FGE),
};

OpShift: Loc<BinaryOp> = {
	Located<"<<"> => <>.map(|_| BinaryOp::LSHIFT),
	Located<">>"> => <>.map(|_| BinaryOp::RSHIFT),
	Located<"s>>"> => <>.map(|_| BinaryOp::SRSHIFT),
}

OpAdd: Loc<BinaryOp> = {
	Located<"+"> => <>.map(|_| BinaryOp::PLUS),
	Located<"-"> => <>.map(|_| BinaryOp::MINUS),
	Located<"f+"> => <>.map(|_| BinaryOp::FPLUS),
	Located<"f-"> => <>.map(|_| BinaryOp::FMINUS),
};

OpMul: Loc<BinaryOp> = {
	Located<"*"> => <>.map(|_| BinaryOp::MUL),
	Located<"/"> => <>.map(|_| BinaryOp::DIV),
	Located<"%"> => <>.map(|_| BinaryOp::MOD),
	Located<"s/"> => <>.map(|_| BinaryOp::SDIV),
	Located<"s%"> => <>.map(|_| BinaryOp::SMOD),
	Located<"f*"> => <>.map(|_| BinaryOp::FMUL),
	Located<"f/"> => <>.map(|_| BinaryOp::FDIV),
};

OpUnary: Loc<UnaryOp> = {
	Located<"!"> => <>.map(|_| UnaryOp::NOT),
	Located<"~"> => <>.map(|_| UnaryOp::INV),
	Located<"-"> => <>.map(|_| UnaryOp::NEG),
	Located<"f-"> => <>.map(|_| UnaryOp::FNEG),
};

//

ConstructorContext: Vec<Statement> = "["	<ContextStatement*> "]";

ContextStatement: Statement = {
	<Assignment> ";",
	<FunCallStmt> ";",
};

ConstructorBody: Vec<Statement> = "{" <Statement*> "}";

pub Macro: Macro = {
	"macro" <id:Ident> "(" <args:ArgNames> ")" "{" <body:Statement+> "}" =>
		Macro { id, args, body: body }
};

pub PCodeOp: LocId = {
	"define" "pcodeop" <Ident> ";"
};

pub Statement: Statement = {
	<Label> => Statement::Label(<>),
	<Assignment> ";",
	<Declaration> ";",
	<FunCallStmt> ";",
	<Build> ";",
	<Goto> ";",
	<Branch> ";",
	<Call> ";",
	<Export> ";",
	<Return> ";",
};

pub Assignment: Statement = {
	"local" <lhs:LValue> "=" <rhs:Expr> => Statement::Bind { lhs, rhs },
	<lhs:LValue> "=" <rhs:Expr> => Statement::Bind { lhs, rhs },
};

pub Declaration: Statement = {
	"local" <left:@L> <lhs:ExprIdent> <right:@R> ":" <size:Number> => {
	    let unit = Expr::Unit(Loc::new((), (left..right).into()));
		let rhs = Expr::Sized { expr: Box::new(unit), size };
		Statement::Bind { lhs, rhs }
	},
	"local" <left:@L> <lhs:ExprIdent> <right:@R> => {
	    let unit = Expr::Unit(Loc::new((), (left..right).into()));
		Statement::Bind { lhs, rhs: unit }
	}

};

pub Build: Statement = {
	"build" <Ident> => Statement::Build(<>),
};

pub FunCall: Expr = {
	<id:Ident> "("	<args:Args> ")" => {
		let args = args.into_iter().map(|x| Box::new(x)).collect();
		Expr::FunCall { id, args }
	},
};

pub FunCallStmt: Statement = {
	<id:Ident> "("	<args:Args> ")" => Statement::FunCall { id, args },
};

pub Goto: Statement = {
	"goto" <target:JumpTarget> => Statement::Goto(<>),
};

pub Branch: Statement = {
	"if" <expr:Expr> "goto" <target:JumpTarget> =>  Statement::Branch { condition:expr, target },
};

pub Call: Statement = {
	"call" <JumpTarget> => Statement::Call(<>),
};

pub Export: Statement = {
	"export" <ExprVarnode> => Statement::Export(<>),
	"export" <SizedPointer<ExprIdent>> => Statement::Export(<>),
};

pub Return: Statement = {
	"return" "[" <JumpTarget> "]" => Statement::Return(<>),
};

pub JumpTarget: JumpTarget = {
	<address:Number> "[" <space:Ident> "]" => JumpTarget::Fixed{ address, space: Some(space) },
	<address:Number> => JumpTarget::Fixed{ address, space: None },
	<Ident> => JumpTarget::Direct(<>),
	"[" <Expr> "]" =>  JumpTarget::Indirect(<>),
	<Label> => JumpTarget::Label(<>),
};

LValue: Expr = {
	<ExprBitRange>,
	<id:ExprIdent> ":" <size:Number> =>
		Expr::Sized { expr: Box::new(id), size },
	<ExprIdent>,
	SizedPointer<Expr>,
};

ExprBitRange: Expr = {
	<id:Ident> "[" <start_bit:Number> "," <bit_width:Number> "]" =>
		Expr::BitRange { id, start_bit, bit_width }
};

pub ExprVarnode: Expr = {
	<ExprNumber>,
	<ExprIdent>,
	<id:ExprIdent> ":" <size:Number> =>
		Expr::Sized { expr: Box::new(id), size },
	<n:ExprNumber> ":" <size:Number> =>
		Expr::Sized { expr: Box::new(n), size },
};

pub Label: LocId = "<" <Ident> ">";
pub ExprIdent: Expr = <Ident> => Expr::Id(<>);
pub ExprNumber: Expr = <Number> => Expr::Int(<>);

pub ArgNames: Vec<LocId> = Sep<Ident, ",">;
pub Args: Vec<Expr> = Sep<Expr, ",">;

SizedPointer<T>: Expr = {
	"*" "[" <space:Ident> "]" ":" <size:Number> <expr:T> => {
		let expr = Box::new(expr);
		let expr = Expr::Pointer { expr, space: Some(space) };
		Expr::Sized { expr: Box::new(expr), size }
	},
	"*" "[" <space:Ident> "]" <expr:T> => {
		Expr::Pointer { expr: Box::new(expr), space: Some(space) }
	},
	"*" ":" <size:Number> <expr:T> => {
		let expr = Expr::Pointer { expr: Box::new(expr), space: None };
		Expr::Sized { expr: Box::new(expr), size }
	},
	"*" <expr:T> => {
		Expr::Pointer { expr: Box::new(expr), space: None }
	},
};

extern {
	type Location = usize;
	type Error = ParserError;

	enum T<'input> {
    "alignment" => T::Normal(NT::Alignment),
    "attach" => T::Normal(NT::Attach),
    "bin int" => T::Normal(NT::BinInt(<usize>)),
    "dec int" => T::Normal(NT::DecInt(<usize>)),
    "hex int" => T::Normal(NT::HexInt(<usize>)),
    "ident" => T::Normal(NT::Ident(<&'input str>)),
    "display ident" => T::Display(DT::Ident(<&'input str>)),
    "is" => T::Display(DT::Is),
    "if" => T::Normal(NT::If),
    "register" => T::Normal(NT::Register),
    "build" => T::Normal(NT::Build),
    "call" => T::Normal(NT::Call),
    "dec" => T::Normal(NT::Dec),
    "define" => T::Normal(NT::Define),
    "endian" => T::Normal(NT::Endian),
    "export" => T::Normal(NT::Export),
    "goto" => T::Normal(NT::Goto),
    "hex" => T::Normal(NT::Hex),
    "local" => T::Normal(NT::Local),
    "macro" => T::Normal(NT::Macro),
    "pcodeop" => T::Normal(NT::PCodeOp),
    "return" => T::Normal(NT::Return),
    "signed" => T::Normal(NT::Signed),
	  "space" => T::Normal(NT::Space),
    "token" => T::Normal(NT::Token),
    "type" => T::Normal(NT::Type),
    "unimpl" => T::Normal(NT::Unimpl),
    "variables" => T::Normal(NT::Variables),
    "..." => T::Normal(NT::Ellipsis),
    "{" => T::Normal(NT::LBrace),
    "}" => T::Normal(NT::RBrace),
    "[" => T::Normal(NT::LBracket),
    "]" => T::Normal(NT::RBracket),
    "(" => T::Normal(NT::LParen),
    ")" => T::Normal(NT::RParen),
    ":" => T::Normal(NT::Colon),
    "," => T::Normal(NT::Comma),
    "!" => T::Normal(NT::Bang),
    "~" => T::Normal(NT::Tilde),
    "," => T::Normal(NT::Comma),
    ";" => T::Normal(NT::Semi),
    "=" => T::Normal(NT::Assign),
    "<" => T::Normal(NT::LT),
    ">" => T::Normal(NT::GT),
    "==" => T::Normal(NT::EQ),
    "!=" => T::Normal(NT::NE),
    "<=" => T::Normal(NT::LE),
    ">=" => T::Normal(NT::GE),
    "||" => T::Normal(NT::Or),
    "&&" => T::Normal(NT::And),
    "^^" => T::Normal(NT::Xor),
    "|" => T::Normal(NT::Pipe),
    "&" => T::Normal(NT::Ampersand),
    "^" => T::Normal(NT::Caret),
    "<<" => T::Normal(NT::LShift),
    ">>" => T::Normal(NT::RShift),
    "+" => T::Normal(NT::Plus),
    "-" => T::Normal(NT::Minus),
    "*" => T::Normal(NT::Star),
    "/" => T::Normal(NT::Slash),
    "%" => T::Normal(NT::Percent),
    "$or" => T::Normal(NT::SpecOr),
    "$and" => T::Normal(NT::SpecAnd),
    "$xor" => T::Normal(NT::SpecXor),
    "f<" => T::Normal(NT::FLT),
    "f>" => T::Normal(NT::FGT),
    "f==" => T::Normal(NT::FEQ),
    "f!=" => T::Normal(NT::FNE),
    "f<=" => T::Normal(NT::FLE),
    "f>=" => T::Normal(NT::FGE),
    "f+" => T::Normal(NT::FPlus),
    "f-" => T::Normal(NT::FMinus),
    "f*" => T::Normal(NT::FMul),
    "f/" => T::Normal(NT::FDiv),
    "s<" => T::Normal(NT::SLT),
    "s>" => T::Normal(NT::SGT),
    "s<=" => T::Normal(NT::SLE),
    "s>=" => T::Normal(NT::SGE),
    "s<<" => T::Normal(NT::SLShift),
    "s>>" => T::Normal(NT::SRShift),
    "s/" => T::Normal(NT::SDiv),
    "s%" => T::Normal(NT::SMod),
    "caret" => T::Display(DT::Caret),
    "text" => T::Display(DT::Text(<&'input str>)),
		" " => T::Display(DT::Whitespace),
	}
}
